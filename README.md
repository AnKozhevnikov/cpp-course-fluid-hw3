# Домашнее задание 3 - отчёт

## Чеклист

- Возможность параллельного запуска и выбора количества потоков - сделано.
- Программа работатет корректно в несколько потоков - сделано.
- Существенное ускорение без использования потоков - сделано
- Наличие любого ускорение за счёт параллелизма на достаточно большом тесте - не сделано.
- Запуск N >= 8 потков даёт ускорение в N/2 раз - не сделано.
- Оформление отчёта - сделано.

## Входные условия
В качестве образца была дана программа. Я её немного модифицировал, чтобы на вход можно было принять количество итераций алгоритма и посчитать время работы. На скорость работы это никак не влияет. Тестировать программу будем на поле точно таком же, какое было в исходном примере на 500 итерациях. Исходная программа, которую будем ускорять лежит в файле fluid_original.cpp. Исходное время будем замерять при сборке с флагом -O0 в Release. Я считаю так будет справедливо, так как при -O0 мы не пользуемся никакими ускорениями, замеряем исключительно исходный код, а сборка в Release, так как нам не нужна информация для дебага.

## Немногопоточные оптимизации

Для оптимизации программы были предприняты следующие меры:

- Сборка с флагом компиляции -O3 - очевидная оптимизация
- Навешивание inline на часть функций - очевидная оптимизация
- В классе Fixed замена int32_t на int_fast32_t - на современных машинах вряд ли даст какую-нибудь оптимизацию, но пусть будет
- Замена в цикле вывода поля cout на printf - printf просто быстрее
- Переписана функция ParticleParams::get - пожалуй одна из интересных оптимизаций. Запуская программу с помощью утилиты perf можно убедиться в том, что суммарно эта функция и всё, что из неё вызвано, занимает целых 20% от времени программы. Оптимизированная же занимает 15% от времени работы программы при использовании всех оптимизаций кроме -O3. Забегая вперёд, время работы в таком случае уменьшается примерно в 3 раза.
- В функции propagate_move переписана строчка с upper_bound, на тернарный оператор, так как массив в котором делается поиск крайне небольшой.

## Многопоточные оптимизации

Для контроля многопоточных функций был написан ThreadPool с возможностью выбора количества потоков.

На данный момент не написано оптимизаций, которые работали бы с многопотоком. Планируется оптимизация всех функций, содержащих в себе поиск в глубину.

## Замеры скорости

Все замеры проводились на моём личном ноутбуке.

| Program                                  | Execution time |
|------------------------------------------|----------------|
| original with -O0, 500 iterations        | 209 seconds    |
| fast with -O0, 500 iterations, 0 threads | 68 seconds     |
| fast with -O3, 500 iterations, 0 threads | 4 seconds      |

## Итоги

Так как запускать программу с -O3 откровенное читерство, то целесообразно сравнивать замеры с одинаковыми флагами компиляции. А в в этом случае оптимизация без многопотока ускорила программу приблизительно в 3 раза, что крайне неплохо.

Программа предусматривает запуск в многопоточном режиме и выбор числа потоков. В многопоточном режиме не ломается логика и всё работает корректно, однако оптимизаций как таковых нет.